<div dir="rtl" align="right">


## المقارنات comparisons  ##
<br>


لقد تعرفت على العديد من أنواع المقارنة في دراستك لمادة الرياضيات.
ولكن في JavaScript تتم كتابتها كما هو موضح أدناه:


* أكبر / أصغر من: a > b, a < b. <br>
* أكبر / أصغر من أو يساوي: a >= b, a <= b. <br>
* يساوي: a == b ، لابد من  ملاحظة أن علامة المساواة المزدوجة == تعني اختبار المساواة ، بينما تعني المساواة الواحدة  a = b الاسناد. <br>
* اللا يساوي. في الرياضيات ، تكون بالترميز ≠ ، لكن في JavaScript تكتب كـ a!= b. <br>
<br>
في هذه الدرس ، سنتعرف على المزيد حول أنواع مختلفة من المقارنات ، وكيف تصنعها JavaScript ، بما في ذلك الخصائص المهمة.

في النهاية ستجد طريقة لتجنب المشكلات المتعلقة بـ "javascript quirks".

 ###  قيمة منطقية boolean هي النتيجة ### 
<br>
تُرجع كافة عوامل المقارنة قيمة منطقية:<br>

* `true`  - تعني "نعم" أو "صحيح" أو "حقيقة". <br>
* `false` - تعني "لا" أو "خطأ" أو "ليست حقيقة". <br>
فمثلا:
<div dir="ltr" align="left">

```js
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
```
</div>

ويمكن إسناد نتيجة المقارنة إلى متغير ، مثل أي قيمة كما موضح في المثال أدناه:
<div dir="ltr" align="left">

```js
let result = 5 > 4; // assign the result of the comparison
alert( result ); // true
```
</div>


 ### مقارنة string ### 
<br>
إذا كنت تريد معرفة هل string أكبر من string الأخرى ، تستخدم JavaScript ما يسمى بترتيب "dictionary" أو "lexicographical".
بمعنى آخر ، تتم مقارنة strings حرف بحرف.

فمثلا:
<div dir="ltr" align="left">

```js
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```
</div>

الخوارزمية المستخدمة للمقارنة بين string و string بسيطة كما هي موضحه أدناه:

قارن الحرف الأول من كلا strings.<br>
إذا كان الحرف الأول من string الأولى أكبر (أو أقل) من string الأخرى ، فإن string الأولى أكبر (أو أقل) من الثانية. وهكذا قد انتهت عملية المقارنة.<br>
اما إذا كانت الأحرف الأولى في كلتا strings متطابقة ، فقارن الأحرف الثانية بنفس الطريقة، وكررها حتى نهاية أي string.<br>
إذا انتهى كلا strings بنفس الطول ، فهما متساويان. غير ذلك ، فإن أطول string تكون هي الأكبر.<br>
<br>
<br>
في المثال أعلاه ، يتم الحصول في مقارنة "Z"> "A" على نتيجة في الخطوة الأولى بينما تتم مقارنة  "Glow" و "Glee" حرف بحرف كما يلي:<br>
* G هو نفس G. <br>
* l هو نفسه l . <br>
* o أكبر من e. تتوقف هنا. أول string هي الأكبر . <br>

💡ليست dictionary حقيقي ، ولكن ترتيب Unicode <br>
تكافئ خوارزمية المقارنة المذكورة أعلاه تقريبًا كتلك المستخدمة في القواميس أو دفاتر الهاتف ، ولكنها ليست متطابقة تمامًا.
على سبيل المثال ، الحرف الكبير "A" لا يساوي الحرف الصغير "a". أيهما أكبر إذا؟ الحرف الصغير "a". لماذا ا؟ لأنه يحتوي على قيمة أكبر في جدول Unicode الذي تستخدمه JavaScript.

 ### مقارنة أنواع مختلفة ### 
<br>
عند مقارنة قيم من أنواع مختلفة ، تقوم JavaScript بتحويل القيم إلى أرقام.

فمثلا:

<div dir="ltr" align="left">

```js
alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
```
</div>

بالنسبة للقيم المنطقية ، `true`  لها القيمة 1 و`false`  لها القيمة 0. كما في المثال أدناه:

<div dir="ltr" align="left">

```js
alert( true == 1 ); // true
alert( false == 0 ); // true
```
</div>

 نتيجة💡 funny
من الممكن في نفس الوقت: 
* أن القيمتان متساويتان. <br>
* أحدهما true  والآخر false . <br>

فمثلا:
<div dir="ltr" align="left">

```js
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```
</div>
من وجهة نظر JavaScript ، هذه النتيجة طبيعية. يقوم عند فحص المساواة بتحويل القيم باستخدام التحويل الرقمي (من "0"  يصبح  0) ، بينما يستخدم التحويل المنطقي الصريح مجموعة أخرى من القواعد.
<br>

 ### المساواة الصارمة ### 
<br>

فحص المساواة الاعتيادي `==` لديه مشكلة وهي لا يمكنه التفريق بين `0` و `false` كما هو موضح أدناه في المثال:
<div dir="ltr" align="left">

```js
alert( 0 == false ); // true
```
</div>

ويحدث نفس الشيء مع string فارغة كما موضح في المثال أدناه:

<div dir="ltr" align="left">

```js
alert( '' == false ); // true
```
</div>

ويحدث هذا بسبب تحويل المعاملات التي من أنواع مختلفة إلى أرقام بواسطة عامل المساواة ==. string الفارغة ، مثل `false` ، تصبح صفراً.
ولكن ما الحل إذا أردنا التفريق بين الصفر و`false` ؟
الحل هو عامل المساواة الصارم `===` وهو يتحقق من المساواة بدون تحويل النوع.
بمعنى ، إذا كان `a` و `b` من نوعين مختلفين ، فإن `a === b` تُرجع خطأً على الفور دون محاولة تحويلهما.

مثال للتوضيح:

<div dir="ltr" align="left">

```js
alert( 0 === false ); // false, because the types are different
```
</div>

ويوجد كذلك عامل "عدم المساواة الصارم `==!` المماثل لـ  `=!`  .
يأخذ عامل المساواة الصارمة وقتًا أطول في الكتابة ، ولكنه يوضح ما يحدث ويترك مجالًا أقل للأخطاء.




 ### المقارنة مع null و undefined ### 
<br>

يوجد سلوك غير بديهي عند مقارنة null أو undefined بالقيم الأخرى. ولفحص صارم للمساواة يتم استخدام `===` ، في المثال أدناه القيم مختلفة ، لأن كل منها من نوع مختلف .

<div dir="ltr" align="left">

```js
alert( null === undefined ); // false
```
</div>

ويحدث نفس الشيء مع string فارغة كما موضح في المثال أدناه:

<div dir="ltr" align="left">

```js
alert( '' == false ); // true
```
</div>

ويحدث هذا بسبب تحويل المعاملات التي من أنواع مختلفة إلى أرقام بواسطة عامل المساواة ==. string الفارغة ، مثل `false` ، تصبح صفراً.
ولكن ما الحل إذا أردنا التفريق بين الصفر و`false` ؟
الحل هو عامل المساواة الصارم `===` وهو يتحقق من المساواة بدون تحويل النوع.
بمعنى ، إذا كان `a` و `b` من نوعين مختلفين ، فإن `a === b` تُرجع خطأً على الفور دون محاولة تحويلهما.

مثال للتوضيح:

<div dir="ltr" align="left">

```js
alert( 0 === false ); // false, because the types are different
```
</div>

اما لفحص غير صارم استخدم  `==` ، وهناك قاعدة خاصة. هذان "sweet couple": كلاهما متساوٍ (بمعنى ==) ، ولكن هذا ينطبق لـ `null` و `undefined `  فقط فلا ينطبق لأي قيمة أخرى.


<div dir="ltr" align="left">

```js
alert( null == undefined ); // true
```
</div>

للرياضيات والمقارنات الأخرى <> <=> =
يتم تحويل `null` و `undefined`إلى أرقام: `null` يصبح 0 ،  `undefined` يصبح `NaN` .
والآن لنرى بعض الأشياء الغير متوقعة التي تحدث عندما نطبق هذه القواعد. والأهم من ذلك كيفية تجنب الوقوع فيها.

 #### نتيجة غريبة: عند مقارنة `null` ب 0 #### 
<br>
لنقارن `null` بصفر كما في المثال أدناه:
<div dir="ltr" align="left">

```js
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```
</div>

رياضياً ،تعتبر النتيجة غريبة. تنص النتيجة الأخيرة على أن `null` أكبر من أو تساوي الصفر ، بينما النتيجتان للمقارنتين التي قبلها خاطئة في حين يجب أن تكون أحداهما صحيحة.
والسبب هو أن فحص المساواة `==`  والمقارنات `> <> = <=` تعمل بشكل مختلف. تحول المقارنات `null` إلى رقم ، وتعامله على أنه 0. ولهذا السبب المقارنة الثالثة `null >= 0` تعطي النتيجة `true` بينما المقارنة الأولى `null > 0` تعطي النتيجة `false`.
من ناحية أخرى ، يتم تعريف التحقق من المساواة `==` لـ `undefined` و`null` بدون عمل أي من التحويلات ، ويتساوى كل منهما مع الآخر ولا يساوي أي شيء آخر. لهذا السبب لمقارنة الثانية `null == 0` تعطي النتيجة `false`.

 #### لا يقارن `undefined`  #### 
<br>

يجب عدم مقارنة القيمة `undefined` بقيم أخرى:
<div dir="ltr" align="left">

```js
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```
</div>
نحصل على هذه النتائج للأسباب التالية:
المقارنات الأولى و الثانية تعيد القيمة  `false` لأنه يتم تحويل  `undefined`إلى `NaN` و `NaN` هي قيمة عددية خاصة ترجع خطأً لجميع المقارنات.
يُرجع فحص المساواة للمقارنة الثالثة `false` لأن قيمة `undefined` تساوي فقط قيمة `null`.
<br>

 #### تجنب المشاكل  #### 
<br>

لا يجب عليك أن نتذكر هذه الخصائص طوال الوقت لأنه في الواقع ، ستصبح هذه الأشياء الصعبة مألوفة تدريجيًا بمرور الوقت ، ولكن هناك طريقة لتجنب المشاكل معها وهي
عند التعامل مع أي مقارنة مع `undefined أو `null` باستثناء المساواة الصارمة `===` يجب عليك التعامل معها بعناية استثنائية.
لا تستخدم المقارنات `> => <<=` مع متغير قد يكون `undefined أو `null` ، إلا إذا كنت متأكدًا مما تفعله. إذا كان المتغير يمكن أن يحتوي على هذه القيم ، فتحقق منها بشكل منفصل.


 ### ملخص ###

* تُرجع عوامل المقارنة قيمة منطقية. <br>
* تتم مقارنة Strings حرف بحرف بترتيب "Dictionary". <br>
* عندما تتم مقارنة قيم من أنواع مختلفة ، يتم تحويلها إلى أرقام (مع استبعاد فحص المساواة الصارم). <br>
* القيم `null` و`undefined` تساوي `==` بعضهما البعض ولا تساوي أي قيمة أخرى. <br>
* كن حذرًا عند استخدام المقارنات مثل `>` أو `<`مع المتغيرات التي يمكن أن تكون أحيانًا  `null` و`undefined`. يعد التحقق من القيمة  `null` و`undefined` بشكل منفصل فكرة جيدة. <br>

<br>

### مهام  ###
#### مقارنات #### 
ماذا ستكون نتيجة هذه المقارنات؟
<div dir="ltr" align="left">

```js
5 > 4
"apple" > "pineapple"
"2" > "12"
undefined == null
undefined === null
null == "\n0\n"
null === +"\n0\n"
```
</div>

الحل :
<div dir="ltr" align="left">

```js
5 > 4 → true
"apple" > "pineapple" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false
```
</div>
</div>
